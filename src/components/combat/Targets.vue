<template>
	<Pane
		id="targets"
		title="Targets"
		:class="{
			'step-highlight': demo && follow_tutorial && get_step('run', 'targets'),
		}"
		@focus="$emit('focus')"
	>
		<button
			slot="header-action"
			class="btn btn-sm bg-neutral-5"
			tabindex="-1"
			:class="{ disabled: test }"
			v-shortkey="{ main: ['='], alt: ['shift', '+'] }"
			@click="test ? null : setDrawer({ show: true, type: 'drawers/encounter/AddNpc' })"
			@shortkey="test ? null : setDrawer({ show: true, type: 'drawers/encounter/AddNpc' })"
		>
			<i aria-hidden="true" class="fas fa-plus green" />
			<span class="ml-1">
				Add
				<hk-show-keybind class="d-none d-sm-inline" :binds="['+']" />
			</span>
			<q-tooltip v-if="test" anchor="top middle" self="center middle"
				>Unavailable in test mode</q-tooltip
			>
		</button>
		<div
			v-shortkey="{
				downSingle: ['arrowdown'],
				downMultiple: ['shift', 'arrowdown'],
				upSingle: ['arrowup'],
				upMultiple: ['shift', 'arrowup'],
			}"
			@shortkey="cycle_target"
		>
			<template v-for="{ group, targets } in groups">
				<h2 :key="`header-${group}`" v-if="group !== 'active' && targets.length > 0">
					<hk-icon v-if="group === 'down'" icon="fas fa-skull-crossbones" class="red mr-1" />
					{{ group.capitalize() }} ({{ targets.length }})
				</h2>
				<draggable
					tag="div"
					:value="targets"
					:animation="200"
					handle=".drag-handle"
					ghost-class="drag-ghost"
					drag-class="drag-dragging"
					:force-fallback="true"
					:key="`sortable-${group}`"
					@end="onDrag"
				>
					<transition-group
						:key="group"
						tag="ul"
						class="targets"
						:class="`${group}_targets`"
						name="group"
						enter-active-class="animated animate__fadeInUp"
						leave-active-class="animated animate__fadeOutDown"
					>
						<li
							v-for="(entity, i) in targets"
							class="d-flex justify-content-between target-li"
							:key="entity.key"
							:class="{
								targeted: targeted.includes(entity.key),
								top: _active[0].key === entity.key && encounter.turn !== 0,
								'step-highlight': i > 0 && demo && follow_tutorial && get_required('run', 'target'),
							}"
							tabindex="0"
							@keydown.space="selectTarget($event, 'single', entity.key)"
						>
							<div
								class="top-of-round"
								v-if="group === 'active' && _active[0].key == entity.key && encounter.turn != 0"
							>
								<div class="top-of-round__title">Top of the Round</div>
								<div class="top-of-round__added" v-if="Object.keys(_addedNextRound).length > 0">
									+ {{ Object.keys(_addedNextRound).length }}
									<q-tooltip anchor="top middle" self="center middle"> Added next round </q-tooltip>
								</div>
								<div class="top-of-round__removed" v-if="Object.keys(_activeDown).length > 0">
									- {{ Object.keys(_activeDown).length }}
									<q-tooltip anchor="top middle" self="center middle">
										Removed next round
									</q-tooltip>
								</div>
							</div>
							<div
								class="target"
								v-touch-hold.mouse="(event) => selectTarget(event, 'multi', entity.key)"
								@click="selectTarget($event, 'single', entity.key)"
								v-shortkey="[i]"
								@shortkey="set_targeted({ type: 'single', key: entity.key })"
							>
								<TargetEntity :entity="entity" />
							</div>
							<div v-if="!entity.active" class="d-flex">
								<a
									class="btn btn-sm btn-clear mx-1"
									v-if="entity.addNextRound"
									v-on:click.stop="add_next_round({ key: entity.key, action: 'tag', value: false })"
								>
									<i aria-hidden="true" class="fas fa-check green" />
									<q-tooltip anchor="top middle" self="center middle">
										Will be added next round
									</q-tooltip>
								</a>
								<a
									class="btn btn-sm btn-clear mx-1"
									v-if="!entity.addNextRound"
									v-on:click.stop="add_next_round({ key: entity.key, action: 'tag', value: true })"
								>
									<i aria-hidden="true" class="fas fa-check neutral-2" />
									<q-tooltip anchor="top middle" self="center middle">
										Click to add next round
									</q-tooltip>
								</a>
								<a
									class="btn btn-sm bg-neutral-5"
									@click="add_next_round({ key: entity.key, action: 'set' })"
								>
									<i aria-hidden="true" class="fas fa-arrow-up" />
									<q-tooltip anchor="top middle" self="center middle"> Add now </q-tooltip>
								</a>
							</div>
							<TutorialPopover
								v-if="demo && group === 'active' && i === 1"
								tutorial="run"
								requirement="target"
								position="right"
								:offset="[10, 0]"
							/>
						</li>
					</transition-group>
				</draggable>
			</template>
		</div>

		<TutorialPopover v-if="demo" tutorial="run" position="right" step="targets" :offset="[10, 0]" />
	</Pane>
</template>

<script>
import _ from "lodash";
import { mapGetters, mapActions } from "vuex";
import Pane from "./Pane.vue";
import TargetEntity from "./entities/TargetEntity.vue";
import TutorialPopover from "src/components/demo/TutorialPopover.vue";
import draggable from "vuedraggable";

export default {
	name: "Targets",
	components: { Pane, TargetEntity, TutorialPopover, draggable },
	props: ["current", "_active", "_idle"],
	data() {
		return {
			userId: this.$store.getters.user ? this.$store.getters.user.uid : undefined,
			currentTarget: {},
		};
	},
	computed: {
		...mapGetters([
			"campaignId",
			"encounterId",
			"encounter",
			"entities",
			"targeted",
			"userSettings",
			"test",
			"demo",
			"turn",
		]),
		...mapGetters("tutorial", ["get_required", "follow_tutorial", "get_step"]),
		groups() {
			return [
				{
					group: "active",
					targets: this._targets,
				},
				{
					group: "idle",
					targets: this._idle,
				},
				{
					group: "down",
					targets: this._down,
				},
			];
		},
		_targets: function () {
			let t = this.encounter.turn;
			let turns = Object.keys(this._active);
			let order = turns.slice(t).concat(turns.slice(0, t));
			return Array.from(order, (i) => this._active[i]);
		},
		_down: function () {
			return _.chain(this.entities)
				.filter(function (entity, key) {
					entity.key = key;
					return !!entity.down;
				})
				.orderBy(function (entity) {
					return parseInt(entity.initiative);
				}, "desc")
				.value();
		},
		//Count NPC's that are down but still in active list
		_activeDown: function () {
			return _.chain(this._targets)
				.filter(function (entity) {
					return entity.curHp == 0 && entity.entityType == "npc";
				})
				.sortBy("name", "desc")
				.value();
		},
		_addedNextRound: function () {
			return _.chain(this._idle)
				.filter(function (entity) {
					return !!entity.addNextRound;
				})
				.sortBy("name", "desc")
				.value();
		},
		tutorial_branch() {
			return this.current.entityType === "player" ? "player" : "monster";
		},
	},
	methods: {
		...mapActions([
			"setDrawer",
			"set_hidden",
			"set_targeted",
			"set_stable",
			"remove_entity",
			"add_next_round",
			"set_initiative",
		]),
		...mapActions("tutorial", ["completeStep"]),
		onDrag(event) {
			const oldIndex = event.oldIndex;
			const newIndex = event.newIndex;
			const entity = this._targets[oldIndex];
			let initiative = entity.initiative;

			// Moving down
			if (oldIndex < newIndex) {
				const previousIndex = newIndex;
				let nextIndex = newIndex === this._targets?.length - 1 ? 0 : newIndex + 1;

				// When the top entity is dragged to bottom, show a warning
				// This action should cause the turn go up
				if (nextIndex === 0 && oldIndex === 0) {
					this.$q.notify({
						message: "Can't drag top to bottom",
						color: "warning",
						position: "top",
						timeout: 1000,
					});
					return;
				}

				const above = this._targets[previousIndex]?.initiative;
				const below = this._targets[nextIndex]?.initiative;

				// When below > above we're dragging to the bottom of the initiative list
				// In that case we can simply make the initiative lower than above
				initiative = below > above ? above / 2 : (above + below) / 2;
			}
			// Moving up
			if (oldIndex > newIndex) {
				const previousIndex = !newIndex ? this._targets?.length - 1 : newIndex - 1;
				const nextIndex = newIndex === this._targets?.length - 1 ? 0 : newIndex;
				const above = this._targets[previousIndex]?.initiative;
				const below = this._targets[nextIndex]?.initiative;

				initiative = (above + below) / 2;
			}
			this.set_initiative({ key: entity.key, initiative: initiative });
		},
		setHidden(key, hidden) {
			if (key) {
				this.set_hidden({
					key: key,
					hidden: hidden,
				});
			} else {
				this.$snotify.error("Select a target", "Hide entity", {});
			}
		},
		remove(key, name) {
			this.$snotify.error(
				'Are you sure you want to remove "' + name + '" from this encounter?',
				"Delete character",
				{
					buttons: [
						{
							text: "Yes",
							action: (toast) => {
								this.remove_entity(key);
								this.$snotify.remove(toast.id);
							},
							bold: false,
						},
						{
							text: "No",
							action: (toast) => {
								this.$snotify.remove(toast.id);
							},
							bold: true,
						},
					],
				}
			);
		},
		selectTarget(e, type, key) {
			type = e.shiftKey ? "multi" : type;
			//Select the target
			this.set_targeted({
				type,
				key,
			});
		},
		cycle_target(event) {
			const lastSelected = this.targeted[this.targeted.length - 1];
			const type =
				event.srcKey === "upSingle" || event.srcKey === "downSingle" ? "single" : "multi"; // Multitarget or not
			//Create array with keys of all targets
			const targetsArray = this._targets.map((item) => {
				return item.key;
			});
			const current = targetsArray.indexOf(lastSelected); //Set the target from where we're gonna select the next

			let index;
			//Select the next target, either up or down based on the key that's pressed
			if (event.srcKey === "downSingle" || event.srcKey === "downMultiple") {
				index = current + 1 < this._targets.length ? current + 1 : 0;
			} else {
				index = current - 1 < 0 ? targetsArray.length - 1 : current - 1;
			}
			const target = targetsArray[index];

			//Select the target
			this.set_targeted({
				type,
				key: target,
			});
		},
	},
};
</script>

<style lang="scss" scoped>
#targets {
	grid-area: targets;
	overflow: hidden;

	.target {
		width: 100%;
	}

	a.options {
		display: inline-block;
		height: 35px;
		line-height: 35px;
		text-align: center;
		width: 25px;
		font-size: 18px;
		color: $neutral-1 !important;

		&:hover {
			color: $blue !important;
		}
	}
	.dropdown-menu {
		left: -30px !important;
		top: 0px !important;

		i {
			width: 18px;
			padding-right: 3px;
			text-align: center;
		}
	}

	h2 {
		margin: 15px 0 10px 0;
		font-size: 18px;
	}
}

ul.targets {
	list-style: none;
	padding: 0;
	margin: 0;
	display: flex;
	flex-direction: column;
	gap: 10px;

	li {
		padding: 5px 5px 5px 0;
		cursor: pointer;
		background: $neutral-5;
		border-radius: $border-radius-small;
		margin-left: 18px;
		border: solid 1px transparent;
		transition: all 0.1s linear;

		&:hover {
			border-color: $neutral-4;
		}
		&.targeted {
			outline: $blue solid 3px;
		}
		.target-item-wrapper {
			border-top-right-radius: 0;
			border-bottom-right-radius: 0;
		}

		.target-menu__button {
			align-self: flex-start;
			font-size: 18px;
			padding: 1px 8px;
		}

		&:focus &:not(&.targeted) {
			outline: $outline;
		}
	}
	li.top {
		position: relative;
		margin-top: 40px;

		.top-of-round {
			position: absolute;
			display: flex;
			justify-content: space-between;
			gap: 3px;
			font-weight: bold;
			cursor: default;
			width: 100%;
			top: -40px;
			margin-left: -25px;
			width: calc(100% + 25px);

			> div {
				background-color: $neutral-9;
				border-radius: $border-radius;
				padding: 3px 8px;
			}
			&__title {
				flex-grow: 1;
			}
			&__added {
				color: $green;
			}
			&__removed {
				color: $red;
			}
		}
	}
}
.targets-move {
	transition: transform 0.6s;
}
.drag {
	&-ghost {
		opacity: 0.6;
	}
	&-handle {
		color: $neutral-2;
		cursor: grab;
	}
	&-dragging {
		opacity: 1 !important;
		margin-top: -75% !important;
		margin-left: -100% !important;
		box-shadow: 0 5px 10px $black;
		background-color: $neutral-9;
		cursor: grabbing;
	}
}
.fadeInUp,
.fadeInDown {
	animation-delay: 0.6s;
}
</style>
